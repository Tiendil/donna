
* TODO partialy automate tools registration

** TODO generate text to insert into codex configs?
* TODO TOML doesn't support None, which is very inconvinient for storing contexts since they can contain any data.
* TODO since every scenario & unit of work in story is treckable, we may want to use integers instead UUIDs as ids for them.
* TODO each cli command should have detailed description
* TODO protect each of cli commands with is_story_exists check
* TODO some cli commands take long text inputs, allow reading them from files
* TODO some cli commands take long text inputs, allow redirecting them from stdin
* TODO do we need to return short "operation is successful" messages from cli commands?
* TODO automatic action request finish on artifact creation
* TODO when we want to get an artifact from the story we do not load the whole index — artifact id should be enough.
* TODO need some task/command to output the whole story spec
* TODO freeze pydantic models which are possible
* TODO codex should explain what it is doing, while executing requests from donna
* TODO currently operation graphs look like overcomplicated state machines, we may want to do one of:
** simplify them by refactoring into more classical state machines
** refactor into smth more powerful than state machines
* TODO rename scenarios into skills?
* TODO install donna as a skill
** easy mode — one of possible skills to use
** hard mode — forse agent to work via donna
* TODO default donna operation that navigates user to others
** check if uncompleted stories exists, list them if so
** ask the user if the new story should be started
* TODO move workflow cli commands into a separate module (from the stories module)
* TODO consolidate all action request logic in a single module
* TODO replace all NotImplementedError exceptions with custom exceptions and smart error handling
* TODO review the dictionary of primary terms
* TODO complex story workflow
** DONE choose the name for the story
** DONE simplest linear workflow: agent description -> goals -> objectives -> risks -> plan -> exectution -> grooming
** TODO list based artifacts
*** TODO LIST artifacts with operations add, remove, replace
*** TODO iterate and groom over goals & objectives
*** TODO iterate over risks
*** TODO build plan from objectives and risks
*** TODO execute the plan by taking actions from the plan
** TODO graph-bases execution of the plan:
*** TODO buiild things-to-do by iterating over it in the contexts of objectives and risjs
*** TODO GRAPH(-LIST) artifacts with additiona operations to describe dependencies between list items
*** TODO build plan on top of things-to-do list
** TODO verify all risks are closed and rollback to planing if not
** TODO verify all objectives are met and rollback to planing if not
** TODO Split the whole worfklow into smaller scenarios/tasks?
** TODO prepare a report after the story is finished
** TODO custom command to run a specific subflow? Or whould we rest it to the agent? It look like agent can deside better, because otherwise we'll introduce a hard coupling between different flows.
* TODO tests
** TODO basic / lowest unit tests for primitive operations
** TODO domain-level unit tests
** TODO intergration tests for workflows/stories/scenarios
* TODO split scenarios descriptions into code and configs, since most of them are configs
* TODO end_to_end_story_cycle — maybe we should move the whole task flows into a separate package? or organize them better?
* TODO codex struggle with artifact names (skips file extensions, until explicitly told to use the full name). Maybe we should simplify artifact names?
* TODO CLI commands should output there results & logs in a consistent way (i.e. by the same code)
* TODO optimize imports by moving most used ones to \__init__.py files
* TODO donna command to output the current state of the story (tasks, action requests). So it can be run like `watch donna status`
* TODO `behavior` can be something on top of workflows
* Universal IDs format notes:
** It will be nice to have shorter IDs like `<type>-<int>-<control-sum>` instead of full UUIDs and simple ints. It should help both humans and agents to work with them.
*** It should be not problem to use integer ids for the parallel execution, since we rarely create entities => there should not be a problem with using a kind of locking mechanism.
** However, there are a lot of questions with implementation.
** It would be easier to track them gloally for the project, but it may be confusing when ids of local entities will jump around.
*** Thus, there may be various scopes for ids: world, story, artifact.
** We may want to use some global, or locally-global counters for various entities to generate integer parts of the ids. However, most of the entities can be counted on the fly => for them we may skip storing the counters. But we may want to use counters becaue of uniformity.
** Some entities, like artifacts, may be intended to be unique named in some context. For example, it is easy to mention `risks.md` artifact in the story operations, rather than `artifact-<random-int>-<random-string>-risks.md` — no need to pass the id around.
** We do not need to work with ids of some entities (like work units, changes, cells) => they may use simpler approach to ids, like uuids. However, we may want to unify all ids to the same format.
